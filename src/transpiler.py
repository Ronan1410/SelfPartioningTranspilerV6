import os
from typing import List
from src.parser import ParsedModule, SourceSegment

class Transpiler:
    """
    Reconstructs the split segments into a single executable Python file,
    instrumented with logging to show execution flow.
    """
    def __init__(self, output_dir: str):
        self.output_dir = output_dir

    def transpile(self, module: ParsedModule, output_filename: str = "transpiled_output.py") -> str:
        output_path = os.path.join(self.output_dir, output_filename)
        
        lines = []
        
        # Header
        lines.append("# Auto-generated by SelfPartitioningTranspilerV5")
        lines.append("import time")
        lines.append("import sys")
        lines.append("")
        lines.append("class SegmentMonitor:")
        lines.append("    @staticmethod")
        lines.append("    def log(seg_id, tags):")
        lines.append("        print(f'\\033[94m[EXEC] Entering Segment: {seg_id} (Tags: {tags})\\033[0m')")
        lines.append("        time.sleep(0.1)")
        lines.append("")
        lines.append("# --- Original Imports preserved below ---")
        lines.append("")
        
        # Reconstruct code
        # Note: Simply concatenating segments works if they were split line-wise.
        # To "instrument" them, we need to insert code. 
        # Inserting code is risky if we split inside a statement (which we try to avoid).
        # Assuming we split at line boundaries.
        
        for seg in module.segments:
            # Attempt to inject logging.
            # We check indentation of the first line.
            first_line = seg.code.split('\n')[0] if seg.code else ""
            indent = len(first_line) - len(first_line.lstrip())
            indent_str = " " * indent
            
            # Only inject log if it looks like a statement start (not a continuation or comment)
            # This is a heuristic.
            is_safe_to_inject = True
            if first_line.strip().startswith("#") or first_line.strip().startswith("@"):
                is_safe_to_inject = False
            if "else:" in first_line or "elif " in first_line or "except" in first_line:
                is_safe_to_inject = False
            
            if is_safe_to_inject:
                log_stmt = f"{indent_str}SegmentMonitor.log('{seg.id}', {seg.tags})"
                lines.append(log_stmt)
                
            lines.append(seg.code)
            lines.append("") # Spacing
            
        with open(output_path, 'w', encoding='utf-8') as f:
            f.write("\n".join(lines))
            
        print(f"Transpiled code written to {output_path}")
        return output_path

class ExecutionWrapper:
    """
    Creates a runner script that executes the transpiled code.
    """
    def __init__(self, output_dir: str):
        self.output_dir = output_dir
        
    def create_runner(self, transpiled_file_name: str):
        runner_path = os.path.join(self.output_dir, "run_transpiled.py")
        
        code = f"""
import os
import sys
import importlib.util

def main():
    print("--- Initializing Segmented Execution ---")
    
    # Path to transpiled file
    module_path = os.path.join(os.path.dirname(__file__), "{transpiled_file_name}")
    
    # Import and execute
    spec = importlib.util.spec_from_file_location("transpiled_module", module_path)
    module = importlib.util.module_from_spec(spec)
    sys.modules["transpiled_module"] = module
    spec.loader.exec_module(module)
    
    print("--- Execution Finished ---")

if __name__ == "__main__":
    main()
"""
        with open(runner_path, 'w', encoding='utf-8') as f:
            f.write(code)
            
        print(f"Runner generated at {runner_path}")
